<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux教程]]></title>
    <url>%2F2018%2F09%2F10%2FLinux%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第 2 章 新手必须掌握的 Linux 命令 man命令中常用按键以及用途 man命令帮助信息的结构以及意义 举例：man man 常用系统工作命令 echo 输出字符串或变量的值。 date 用于显示及设置系统的时间或日期。date [选项] [+指定的格式] 其中+可以格式化。 参数列表： 举例：date &quot;+%Y-%m-%d %H:%M:%S&quot; reboot 重启系统 poweroff 关闭系统 wget 用于在终端中下载网络文件 参数列表： 举例：wget https://www.linuxprobe.com/docs/LinuxProbe.pdf ps 用于查看系统中的进程状态 参数列表： 在 Linux 系统中，有5中常见的进程状态，分别为运行，中断，不可中断，僵死与停止，其各自含义如下所示。 进程状态各列的含义： 1在Linux系统中的命令参数有长短格式之分，长格式和长格式之间不能合并，长格式和短格式之间也不能合并，但短格式和短格式之间是可以合并的，合并后仅保留一个-（减号）即可。另外ps命令可允许参数不加减号（-），因此可直接写成ps aux的样子。 top 用于动态监视进程活动与系统负载等信息。 pidof 用于查询某个指定服务进程的PID值。 举例： kill 用于终止某个指定PID的服务进程。 killall 用于终止某个指定名称的服务所对应的 全部 进程。 系统状态检测命令 ifconfig 用于获取网卡配置与网络状态等信息。 主要用处： 1使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量 uname 用于查看系统内核与系统版本等信息。 1在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。 举例： 12uname -acat /etc/redhat-release uptime 用于查看系统的负载信息。 跟top第一行应该是一样的。 free 用于显示当前系统中内存的使用量信息。 举例：free -h -h人性化显示（GB，MB之类的） who 用于查看当前登入主机的用户终端信息。 last 用于查看所有系统的登录记录。 history 用于显示历史执行过的命令。 1执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。 sosreport 用于收集系统配置及架构信息并输出诊断文件。 1当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。 工作目录切换命令 pwd 用于显示用户当前所处的工作目录。 cd 用于切换工作路径。 cd - 返回上一次所处的目录。 1使用“cd ..”命令进入上级目录，以及使用“cd ~”命令切换到当前用户的家目录，亦或使用“cd ~username”切换到其他用户的家目录。 ls 用于显示目录中的文件信息。 12使用ls命令的“-a”参数看到全部文件（包括隐藏文件），使用“-l”参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行ls命令即可查看当前目录中的所有文件并输出这些文件的属性信息。如果想要查看目录属性信息，则需要额外添加一个-d参数。 文本文件编辑命令 Linux “一切皆文件” cat 用于查看纯文本文件（内容较少的）。 cat -n 显示行号。 more 用于查看纯文本文件。 空格或回车 翻页。 head 用于查看纯文本文档的前 N 行。 tail 用于查看纯文本文档的后 N 行或 持续刷新内容。 持续刷新内容举例 tail -f test: tr 用于替换文本文件中的字符，tr 「原始字符」 「目标字符」 wc 用于统计指定文本的行数，字数，字节数。 参数列表： wc -l /var/log/messages stat 用于查看文件的具体存储信息和时间等信息。 cut 用于按列提取文本字符。-d设置间隔符号，-f设置需要查看的列数，-c指定提取内容的字符串个数。 head -10 /etc/shadow | cut -d: -f1 head -10 /etc/passwd | cut -c2-4 diff 用于比较多个文本文件的差异。 文件目录管理命令 touch 用于创建空白文件或设置文件的时间。 1对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime） 参数列表： 举例： mkdir 用于创建空白的目录。 cp 用于复制文件或目录。 参数列表： mv 用于剪切文件或将文件重命名。 rm 用于删除文件或目录。 dd 用于按照指定大小和个数的数据块来复制文件或转换文件。 参数列表： 1Linux系统中有一个名为/dev/zero的设备文件，这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为dd命令的输入文件，来生成一个指定大小的文件。 例子： dd if=/dev/zero of=hh count=2 bs=20M 总文件大小”2*20M = 40M” file 用于查看文件的类型。 举例： 打包压缩与搜索命令 tar 用于对文件进行打包压缩或解压。 参数列表： 1234首先，-c参数用于创建压缩文件，-x参数用于解压文件，因此这两个参数不能同时使用。其次，-z参数指定使用Gzip格式来压缩或解压文件，-j参数指定使用bzip2格式来压缩或解压文件。用户使用时则是根据文件的后缀来决定应使用何种格式参数进行解压。在执行某些压缩或解压操作时，可能需要花费数个小时，如果屏幕一直没有输出，您一方面不好判断打包的进度情况，另一方面也会怀疑电脑死机了，因此非常推荐使用-v参数向用户不断显示压缩或解压的过程。-C参数用于指定要解压到哪个指定的目录。！！！（重要）-f参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。 grep 用于在文本中执行关键词搜索，并显示匹配的结果。 参数列表： 举例： find 用于按照指定条件来查找文件。 参数列表： 例子： find / -type f -name &quot;*.conf&quot; -exec stat -c &quot;%s %n&quot; {} \; | sort -nr | head -10 12其中的&#123;&#125;表示搜索出的每一个文件。stat -c &quot;%s %n&quot; filename. 复习题12使用uptime命令查看系统负载时，对应的负载数值如果是0.91、0.56、0.32，那么最近15分钟内负载压力最大的是哪个时间段？答：通过负载数值可以看出，最近1分钟内的负载压力是最大的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux makefile实验]]></title>
    <url>%2F2018%2F04%2F25%2FLinux%20makefile%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[按照以下目录结构存放程序，然后制作makefile文件，把makefile文件内容填入表格中。 现有一个程序由5个文件组成: 123456789/* ./main.c */#include "mytool1.h"#include "mytool2.h"int main()&#123; mytool1_print("hello mytool1!\n"); mytool2_print("hello mytool2!\n"); return 0;&#125; 1234567/* ./functions/mytool1.c */#include "mytool1.h"#include &lt;stdio.h&gt;void mytool1_print(char *print_str)&#123; printf("This is mytool1 print : %s ",print_str);&#125; 12345/* ./functions/mytool1.h */#ifndef _MYTOOL_1_H#define _MYTOOL_1_H void mytool1_print(char *print_str);#endif 12345678/* ./functions/mytool2.c */#include "mytool2.h"#include &lt;stdio.h&gt; void mytool2_print(char *print_str)&#123; printf("This is mytool2 print : %s ",print_str);&#125; 12345/* ./functions/mytool2.h */#ifndef _MYTOOL_2_H#define _MYTOOL_2_H void mytool2_print(char *print_str);#endif 1234567891011./Makefilemain:mytool1.o mytool2.o main.o gcc mytool1.o mytool2.o main.o -o mainmain.o:main.c ./functions/mytool1.h ./functions/mytool2.h gcc -c main.c -o main.o -I functionsmytool1.o:./functions/mytool1.c ./functions/mytool1.h gcc -c ./functions/mytool1.c -o mytool1.omytool2.o:./functions/mytool2.c ./functions/mytool2.h gcc -c ./functions/mytool2.c -o mytool2.oclean: rm -rf *.o main 输出结果：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux shell程序设计实验2]]></title>
    <url>%2F2018%2F04%2F22%2FLinux%20shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C2%2F</url>
    <content type="text"><![CDATA[编写一个shell过程完成如下功能（必须在脚本中使用函数） 1.程序接收3个参数:$1/$2和$3,合并两个文件$1/$2为$3,并显示，三个文件均为文本文件。2.如果文件$3不存在，那么先报告缺少$3，然后将合并后的内容输出到mydoc.txt。如果有$3，就合并到$3。3.如果文件$2或文件$3不存在，那么先报告缺少$2/$3，只显示$1的内容。 4.如果文件$1不存在，则提示缺少$1，要求重新运行程序。 12345678910111213141516171819202122232425262728293031#!/bin/sh function f1()&#123; echo "missing \$2 and \$3" echo "output \$1:" cat $1&#125; function f2()&#123; echo "missing \$3, output mydoc.txt:" cat $1 $2 &gt;mydoc.txt cat mydoc.txt&#125; function error()&#123; echo "missing \$1 \$2 \$3, error!"&#125; if [ $# -eq 0 ]; then errorelif [ $# -eq 1 ]; then f1 $1elif [ $# -eq 2 ]; then f2 $1 $2elif [ $# -eq 3 ]; then cat $1 $2 &gt;$3 echo "output \$3:" cat $3 fi exit 0]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux shell程序设计实验1]]></title>
    <url>%2F2018%2F04%2F21%2FLinux%20shell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C1%2F</url>
    <content type="text"><![CDATA[实验1-1 设计如下一个菜单驱动程序 Use one of the following options:P:To display current directoryS:To display the name of running fileD:To display today’s date and present time (要求显示为：2017-04-26 05:45:12)L:To see the list of files in your present working directoryW:To see who is logged inQ:To quit this programEnter your option and hit:菜单程序将根据用户输入的选择项给出相应信息。要求对用户的输入忽略大小写，对于无效选项的输入给出相应提示。要求使用case语句实现以上功能，输入相应的字母后应该执行相应的命令完成每项功能，如输入P或p，就执行pwd命令。 实验1-2编写一段bash shell程序，根据键盘输入的学生成绩，显示相应的成绩登等级，其中60分以下为”Failed!”,60～69分为”Passed!”,70~79分为”Medium!”,80~89分为”Good!”，90～100为”Excellent!”。如果输入超过100的分数，则显示错误分数提示。 如果输入负数，则退出程序，否则一直提示用户输入成绩 1-1 12345678910111213141516171819202122232425262728293031323334#!/bin/bashclearecho "Use one of the following options:P:To display current directoryS:To display the name of running fileD:To display today's date and present timeL:To see the list of files in your present working directoryW:To see who is logged inQ:To quit this programEnter your option and hit:"read anscase "$ans" inP|p) pwd ;;S|s) ls ;;D|d) date -d '2017-04-26 05:45:12' '+%Y-%m-%d %H:%M:%S' ;;L|l) ls -l ;;W|w) who ;;Q|q) exit 1 ;;*) exit 1esacexit 0 1-2 12345678910111213141516171819202122232425262728#!/bin/bashwhile trueecho "Please input your score: (0 - 100)"doread scoreif [ $score -lt 0 ];then breakelif [ $score -lt 60 ];then echo "Failed!"elif [ $score -lt 70 ];then echo "Passed!"elif [ $score -lt 80 ];then echo "Medium!"elif [ $score -lt 90 ];then echo "Good!"elif [ $score -le 100 ];then echo "Excellent!"else echo "the score must be smaller than 100"fidoneexit 0]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux实验二]]></title>
    <url>%2F2018%2F04%2F20%2FLinux%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Linux实验二 实验环境:win10 + redhat51、创建组testgroup；1groupadd testgroup 2、创建用户a2012，先采用默认设置创建，然后使该用户加入testgroup组。1vi /etc/groupd //在后面添加a2012 3、创建用户a2013，其用户主目录为/tmp/a2013，其主组为testgroup，附加组为users。1useradd -d /tmp/a2013 -g testgroup -G users a2013 4、用id命令显示a2012和a2013用户信息，并且把这些信息记录到日志文件/tmp/test.log中。12su a2012id 12su 2013id 5、参考书本98-99页crontab命令内容，使用root执行crontab -e，编写时程表，完成每隔5分钟把当前时间追加进/tmp/test.log中。1crontab -e 15 * * * * data &gt;&gt; /tmp/test.log 6、执行crontab -l，把输出内容追加进/tmp/test.log。1crontab -l &gt;&gt; /tmp/test.log 7、待完成2次时间记录追加后，执行crontab -r删除当前的时程表。1crontab -r 8、把/tmp/test.log拷贝到windows中（注意文本格式的转换），采用记事本打开，看是否看到完整内容。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux课堂练习1]]></title>
    <url>%2F2018%2F04%2F16%2FLinux%E8%AF%BE%E5%A0%82%E7%BB%83%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[环境：win10 + redhat 5 1、创建组testgroup；1groupadd testgroup 2、创建用户a2012，先采用默认设置创建，然后使该用户加入testgroup组。12useradd a2012usermod -g testgroup 3、创建用户a2013，其用户主目录为/tmp/a2013，其主组为testgroup，附加组为users。123useradd a2013usermod -g testgroupusermod -G users 4、用id命令显示a2012和a2013用户信息，并且把这些信息记录到日志文件/tmp/test.log中。12id a2012 &gt; /tmp/test.logid a2013 &gt;&gt; /tmp/test.log 5、参考书本98-99页crontab命令内容，使用root执行crontab -e，编写时程表，完成每隔5分钟把当前时间追加进/tmp/test.log中。12crontab -e*/5 * * * * date &gt;&gt; /tmp/test.log 6、执行crontab -l，把输出内容追加进/tmp/test.log。1crontab -l &gt;&gt; /tmp/test.log 7、待完成2次时间记录追加后，执行crontab -r删除当前的时程表。1crontab -r 8、把/tmp/test.log拷贝到windows中（注意文本格式的转换），采用记事本打开，看是否看到完整内容。1unix2dos test.log #将unix中的换行符转换为dos环境下能识别的类型 最后将文件复制到win环境下得到test.log]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux实验一]]></title>
    <url>%2F2018%2F04%2F12%2FLinux%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Linux实验一 环境：win10 + redhat 51、root帐号登录，查看/tmp目录，如果/tmp目录下没有子目录myshare，则建立该目录。1ls /tmp | grep myshare 1mkdir -p /tmp/myshare 2、创建帐号testuser。1useradd testuser 1passwd testuser 3、把myshare目录及其目录下的所有文件和子目录的拥有者该为testuser，工作组改为users。1chown -R testuser:users /tmp/myshare 4、切换至testuser帐号。进入/tmp/myshare目录，采用vim编辑器编写以下程序,程序名称为hello.sh： #!/bin/bashecho “app start”echo -efunc (){ echo “hello world!”}funcecho -eecho “app end”1su testuser 1vim /tmp/myshare/hello.sh 5、保存hello.sh后，给予hello.sh拥有者可读、可写和可执行的权限，同组可读可执行，其他人可执行权限。1chmod 751 hello.sh 6、输入./hello.sh，观察程序输出的效果。1./hello.sh 7、进入testuser的用户主目录，在这个目录下创建hello.sh的软链接，同时拷贝hello.sh到该目录下并改名为hello.sh.bak，要求copy时保留文件属性值。1ln -s /tmp/myshare/hello.sh 1cp -p /tmp/myshare/hello.sh /home/testuser/hello.sh.bak 8、退出testuser帐号，回到root帐号，从/开始查找后缀名为.conf的所有文件，把输出结果重定向到testuser帐号的主目录下的output.txt文件。1exit 1find / -type f -name ".conf" &gt;&gt; /home/testuser/output.txt 9、在上一步操作的.conf文件中找出文件容量最大的和最小那个，并把这两个文件的容量大小输出到output.txt文件中。&gt;&gt;1find / -type f -name ".conf" -ls | awk '&#123;print $7&#125;'|sort -n &gt; /home/testuser/tmp.out 1head -1 /home/testuser/tmp.out &gt;&gt; /home/testuser/output.txt 1tail -1 /home/testuser/tmp.out &gt;&gt; /home/testuser/output.txt 10、统计出系统中有多少个用户帐号，把数量输出到output.txt文件中。1cat /etc/passwd | wc -l &gt;&gt; /home/testuser/output.txt 11、把output.txt文件转换为windows记事本可正规打开的格式。1unix2doc output.txt 12、tar打包压缩testuser帐号主目录下的所有文件。1tar zcvf testuser.tar.gz /home/testuser 13、把tar文件另存在window系统下。U盘或者ftp 14、执行userdel -r testuser，执行rm -fr myshare]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux实验</tag>
      </tags>
  </entry>
</search>
